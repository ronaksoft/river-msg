// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: chat.message.markups.proto

package msg

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReplyKeyboardMarkup
type ReplyKeyboardMarkup struct {
	// Requests clients to hide the keyboard as soon as it's been used.
	// The keyboard will still be available, but clients will automatically display the usual letter-keyboard
	// in the chat – the user can press a special button in the input field
	// to see the custom keyboard again.
	SingleUse bool `protobuf:"varint,1,opt,name=SingleUse" json:"SingleUse"`
	// Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users
	// that are @mentioned in the text of the Message object; 2) if the bot's message is a reply
	// (has reply_to_message_id), sender of the original message.
	// Example: A user requests to change the bot‘s language, bot replies to the request with a keyboard
	// to select the new language. Other users in the group don’t see the keyboard.
	Selective bool `protobuf:"varint,2,opt,name=Selective" json:"Selective"`
	// Requests clients to resize the keyboard vertically for optimal fit
	// (e.g., make the keyboard smaller if there are just two rows of buttons). If not set, the custom
	// keyboard is always of the same height as the app's standard keyboard.
	Resize bool                 `protobuf:"varint,3,opt,name=Resize" json:"Resize"`
	Rows   []*KeyboardButtonRow `protobuf:"bytes,4,rep,name=Rows" json:"Rows,omitempty"`
}

func (m *ReplyKeyboardMarkup) Reset()         { *m = ReplyKeyboardMarkup{} }
func (m *ReplyKeyboardMarkup) String() string { return proto.CompactTextString(m) }
func (*ReplyKeyboardMarkup) ProtoMessage()    {}
func (*ReplyKeyboardMarkup) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{0}
}
func (m *ReplyKeyboardMarkup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyKeyboardMarkup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyKeyboardMarkup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyKeyboardMarkup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyKeyboardMarkup.Merge(m, src)
}
func (m *ReplyKeyboardMarkup) XXX_Size() int {
	return m.Size()
}
func (m *ReplyKeyboardMarkup) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyKeyboardMarkup.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyKeyboardMarkup proto.InternalMessageInfo

func (m *ReplyKeyboardMarkup) GetSingleUse() bool {
	if m != nil {
		return m.SingleUse
	}
	return false
}

func (m *ReplyKeyboardMarkup) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

func (m *ReplyKeyboardMarkup) GetResize() bool {
	if m != nil {
		return m.Resize
	}
	return false
}

func (m *ReplyKeyboardMarkup) GetRows() []*KeyboardButtonRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

// ReplyInlineMarkup
type ReplyInlineMarkup struct {
	Rows []*KeyboardButtonRow `protobuf:"bytes,1,rep,name=Rows" json:"Rows,omitempty"`
}

func (m *ReplyInlineMarkup) Reset()         { *m = ReplyInlineMarkup{} }
func (m *ReplyInlineMarkup) String() string { return proto.CompactTextString(m) }
func (*ReplyInlineMarkup) ProtoMessage()    {}
func (*ReplyInlineMarkup) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{1}
}
func (m *ReplyInlineMarkup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyInlineMarkup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyInlineMarkup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyInlineMarkup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyInlineMarkup.Merge(m, src)
}
func (m *ReplyInlineMarkup) XXX_Size() int {
	return m.Size()
}
func (m *ReplyInlineMarkup) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyInlineMarkup.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyInlineMarkup proto.InternalMessageInfo

func (m *ReplyInlineMarkup) GetRows() []*KeyboardButtonRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

// ReplyKeyboardHide
type ReplyKeyboardHide struct {
	// Use this flag if you want to remove the keyboard for specific users only. Targets:
	// 1) users that are @mentioned in the text of the Message object;
	// 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message.
	Selective bool `protobuf:"varint,1,req,name=Selective" json:"Selective"`
}

func (m *ReplyKeyboardHide) Reset()         { *m = ReplyKeyboardHide{} }
func (m *ReplyKeyboardHide) String() string { return proto.CompactTextString(m) }
func (*ReplyKeyboardHide) ProtoMessage()    {}
func (*ReplyKeyboardHide) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{2}
}
func (m *ReplyKeyboardHide) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyKeyboardHide) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyKeyboardHide.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyKeyboardHide) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyKeyboardHide.Merge(m, src)
}
func (m *ReplyKeyboardHide) XXX_Size() int {
	return m.Size()
}
func (m *ReplyKeyboardHide) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyKeyboardHide.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyKeyboardHide proto.InternalMessageInfo

func (m *ReplyKeyboardHide) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// ReplyKeyboardHide
// Force the user to send a reply
type ReplyKeyboardForceReply struct {
	// Requests clients to hide the keyboard as soon as it's been used.
	// The keyboard will still be available, but clients will automatically display the usual letter-keyboard
	// in the chat – the user can press a special button in the input field
	// to see the custom keyboard again.
	SingleUse bool `protobuf:"varint,1,opt,name=SingleUse" json:"SingleUse"`
	// Use this flag if you want to remove the keyboard for specific users only. Targets:
	// 1) users that are @mentioned in the text of the Message object;
	// 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message.
	Selective bool `protobuf:"varint,2,opt,name=Selective" json:"Selective"`
}

func (m *ReplyKeyboardForceReply) Reset()         { *m = ReplyKeyboardForceReply{} }
func (m *ReplyKeyboardForceReply) String() string { return proto.CompactTextString(m) }
func (*ReplyKeyboardForceReply) ProtoMessage()    {}
func (*ReplyKeyboardForceReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{3}
}
func (m *ReplyKeyboardForceReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplyKeyboardForceReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplyKeyboardForceReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplyKeyboardForceReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplyKeyboardForceReply.Merge(m, src)
}
func (m *ReplyKeyboardForceReply) XXX_Size() int {
	return m.Size()
}
func (m *ReplyKeyboardForceReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplyKeyboardForceReply.DiscardUnknown(m)
}

var xxx_messageInfo_ReplyKeyboardForceReply proto.InternalMessageInfo

func (m *ReplyKeyboardForceReply) GetSingleUse() bool {
	if m != nil {
		return m.SingleUse
	}
	return false
}

func (m *ReplyKeyboardForceReply) GetSelective() bool {
	if m != nil {
		return m.Selective
	}
	return false
}

// KeyboardButtonRow
// This is a list of buttons
type KeyboardButtonRow struct {
	Buttons []*KeyboardButtonEnvelope `protobuf:"bytes,1,rep,name=Buttons" json:"Buttons,omitempty"`
}

func (m *KeyboardButtonRow) Reset()         { *m = KeyboardButtonRow{} }
func (m *KeyboardButtonRow) String() string { return proto.CompactTextString(m) }
func (*KeyboardButtonRow) ProtoMessage()    {}
func (*KeyboardButtonRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{4}
}
func (m *KeyboardButtonRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyboardButtonRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyboardButtonRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyboardButtonRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyboardButtonRow.Merge(m, src)
}
func (m *KeyboardButtonRow) XXX_Size() int {
	return m.Size()
}
func (m *KeyboardButtonRow) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyboardButtonRow.DiscardUnknown(m)
}

var xxx_messageInfo_KeyboardButtonRow proto.InternalMessageInfo

func (m *KeyboardButtonRow) GetButtons() []*KeyboardButtonEnvelope {
	if m != nil {
		return m.Buttons
	}
	return nil
}

// KeyboardButtonEnvelope
// This is an envelope for buttons
type KeyboardButtonEnvelope struct {
	Constructor int64  `protobuf:"varint,1,req,name=Constructor" json:"Constructor"`
	Data        []byte `protobuf:"bytes,2,opt,name=Data" json:"Data"`
}

func (m *KeyboardButtonEnvelope) Reset()         { *m = KeyboardButtonEnvelope{} }
func (m *KeyboardButtonEnvelope) String() string { return proto.CompactTextString(m) }
func (*KeyboardButtonEnvelope) ProtoMessage()    {}
func (*KeyboardButtonEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{5}
}
func (m *KeyboardButtonEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyboardButtonEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyboardButtonEnvelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyboardButtonEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyboardButtonEnvelope.Merge(m, src)
}
func (m *KeyboardButtonEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *KeyboardButtonEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyboardButtonEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_KeyboardButtonEnvelope proto.InternalMessageInfo

func (m *KeyboardButtonEnvelope) GetConstructor() int64 {
	if m != nil {
		return m.Constructor
	}
	return 0
}

func (m *KeyboardButtonEnvelope) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// Button
// This button do nothing and is just showing a text
type Button struct {
	Text string `protobuf:"bytes,1,req,name=Text" json:"Text"`
}

func (m *Button) Reset()         { *m = Button{} }
func (m *Button) String() string { return proto.CompactTextString(m) }
func (*Button) ProtoMessage()    {}
func (*Button) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{6}
}
func (m *Button) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Button) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Button.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Button) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Button.Merge(m, src)
}
func (m *Button) XXX_Size() int {
	return m.Size()
}
func (m *Button) XXX_DiscardUnknown() {
	xxx_messageInfo_Button.DiscardUnknown(m)
}

var xxx_messageInfo_Button proto.InternalMessageInfo

func (m *Button) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// ButtonUrl
// Client must open the url
type ButtonUrl struct {
	Text string `protobuf:"bytes,1,req,name=Text" json:"Text"`
	Url  string `protobuf:"bytes,2,req,name=Url" json:"Url"`
}

func (m *ButtonUrl) Reset()         { *m = ButtonUrl{} }
func (m *ButtonUrl) String() string { return proto.CompactTextString(m) }
func (*ButtonUrl) ProtoMessage()    {}
func (*ButtonUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{7}
}
func (m *ButtonUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ButtonUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonUrl.Merge(m, src)
}
func (m *ButtonUrl) XXX_Size() int {
	return m.Size()
}
func (m *ButtonUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonUrl.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonUrl proto.InternalMessageInfo

func (m *ButtonUrl) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ButtonUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// ButtonCallback
// Client must use BotGetCallbackQuery to get a CallbackAnswer from the bot
type ButtonCallback struct {
	Text string `protobuf:"bytes,1,req,name=Text" json:"Text"`
	Data []byte `protobuf:"bytes,2,opt,name=Data" json:"Data"`
}

func (m *ButtonCallback) Reset()         { *m = ButtonCallback{} }
func (m *ButtonCallback) String() string { return proto.CompactTextString(m) }
func (*ButtonCallback) ProtoMessage()    {}
func (*ButtonCallback) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{8}
}
func (m *ButtonCallback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonCallback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonCallback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ButtonCallback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonCallback.Merge(m, src)
}
func (m *ButtonCallback) XXX_Size() int {
	return m.Size()
}
func (m *ButtonCallback) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonCallback.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonCallback proto.InternalMessageInfo

func (m *ButtonCallback) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ButtonCallback) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ButtonRequestPhone
// Button to request a user's phone number
type ButtonRequestPhone struct {
	Text string `protobuf:"bytes,1,req,name=Text" json:"Text"`
}

func (m *ButtonRequestPhone) Reset()         { *m = ButtonRequestPhone{} }
func (m *ButtonRequestPhone) String() string { return proto.CompactTextString(m) }
func (*ButtonRequestPhone) ProtoMessage()    {}
func (*ButtonRequestPhone) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{9}
}
func (m *ButtonRequestPhone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonRequestPhone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonRequestPhone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ButtonRequestPhone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonRequestPhone.Merge(m, src)
}
func (m *ButtonRequestPhone) XXX_Size() int {
	return m.Size()
}
func (m *ButtonRequestPhone) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonRequestPhone.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonRequestPhone proto.InternalMessageInfo

func (m *ButtonRequestPhone) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// ButtonRequestGeoLocation
// Button to request a user's geolocation
type ButtonRequestGeoLocation struct {
	Text string `protobuf:"bytes,1,req,name=Text" json:"Text"`
}

func (m *ButtonRequestGeoLocation) Reset()         { *m = ButtonRequestGeoLocation{} }
func (m *ButtonRequestGeoLocation) String() string { return proto.CompactTextString(m) }
func (*ButtonRequestGeoLocation) ProtoMessage()    {}
func (*ButtonRequestGeoLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{10}
}
func (m *ButtonRequestGeoLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonRequestGeoLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonRequestGeoLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ButtonRequestGeoLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonRequestGeoLocation.Merge(m, src)
}
func (m *ButtonRequestGeoLocation) XXX_Size() int {
	return m.Size()
}
func (m *ButtonRequestGeoLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonRequestGeoLocation.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonRequestGeoLocation proto.InternalMessageInfo

func (m *ButtonRequestGeoLocation) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// ButtonSwitchInline
// Button to force a user to switch to inline mode Pressing the button will prompt the user
// to select one of their chats, open that chat and insert the bot‘s username and the
// specified inline query in the input field.
type ButtonSwitchInline struct {
	Text     string `protobuf:"bytes,1,req,name=Text" json:"Text"`
	Query    string `protobuf:"bytes,2,req,name=Query" json:"Query"`
	SamePeer bool   `protobuf:"varint,3,opt,name=SamePeer" json:"SamePeer"`
}

func (m *ButtonSwitchInline) Reset()         { *m = ButtonSwitchInline{} }
func (m *ButtonSwitchInline) String() string { return proto.CompactTextString(m) }
func (*ButtonSwitchInline) ProtoMessage()    {}
func (*ButtonSwitchInline) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{11}
}
func (m *ButtonSwitchInline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonSwitchInline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonSwitchInline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ButtonSwitchInline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonSwitchInline.Merge(m, src)
}
func (m *ButtonSwitchInline) XXX_Size() int {
	return m.Size()
}
func (m *ButtonSwitchInline) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonSwitchInline.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonSwitchInline proto.InternalMessageInfo

func (m *ButtonSwitchInline) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *ButtonSwitchInline) GetQuery() string {
	if m != nil {
		return m.Query
	}
	return ""
}

func (m *ButtonSwitchInline) GetSamePeer() bool {
	if m != nil {
		return m.SamePeer
	}
	return false
}

// ButtonBuy
// Button to buy a product
type ButtonBuy struct {
	Text string `protobuf:"bytes,1,req,name=Text" json:"Text"`
}

func (m *ButtonBuy) Reset()         { *m = ButtonBuy{} }
func (m *ButtonBuy) String() string { return proto.CompactTextString(m) }
func (*ButtonBuy) ProtoMessage()    {}
func (*ButtonBuy) Descriptor() ([]byte, []int) {
	return fileDescriptor_b77be3a3e9ba7a4e, []int{12}
}
func (m *ButtonBuy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ButtonBuy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ButtonBuy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ButtonBuy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ButtonBuy.Merge(m, src)
}
func (m *ButtonBuy) XXX_Size() int {
	return m.Size()
}
func (m *ButtonBuy) XXX_DiscardUnknown() {
	xxx_messageInfo_ButtonBuy.DiscardUnknown(m)
}

var xxx_messageInfo_ButtonBuy proto.InternalMessageInfo

func (m *ButtonBuy) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func init() {
	proto.RegisterType((*ReplyKeyboardMarkup)(nil), "msg.ReplyKeyboardMarkup")
	proto.RegisterType((*ReplyInlineMarkup)(nil), "msg.ReplyInlineMarkup")
	proto.RegisterType((*ReplyKeyboardHide)(nil), "msg.ReplyKeyboardHide")
	proto.RegisterType((*ReplyKeyboardForceReply)(nil), "msg.ReplyKeyboardForceReply")
	proto.RegisterType((*KeyboardButtonRow)(nil), "msg.KeyboardButtonRow")
	proto.RegisterType((*KeyboardButtonEnvelope)(nil), "msg.KeyboardButtonEnvelope")
	proto.RegisterType((*Button)(nil), "msg.Button")
	proto.RegisterType((*ButtonUrl)(nil), "msg.ButtonUrl")
	proto.RegisterType((*ButtonCallback)(nil), "msg.ButtonCallback")
	proto.RegisterType((*ButtonRequestPhone)(nil), "msg.ButtonRequestPhone")
	proto.RegisterType((*ButtonRequestGeoLocation)(nil), "msg.ButtonRequestGeoLocation")
	proto.RegisterType((*ButtonSwitchInline)(nil), "msg.ButtonSwitchInline")
	proto.RegisterType((*ButtonBuy)(nil), "msg.ButtonBuy")
}

func init() { proto.RegisterFile("chat.message.markups.proto", fileDescriptor_b77be3a3e9ba7a4e) }

var fileDescriptor_b77be3a3e9ba7a4e = []byte{
	// 485 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x93, 0xcd, 0x6e, 0xd3, 0x40,
	0x14, 0x85, 0xe3, 0x38, 0x94, 0xe6, 0x16, 0x21, 0x75, 0x90, 0x82, 0x15, 0x2a, 0x13, 0x8d, 0x04,
	0xaa, 0x90, 0x70, 0x25, 0x04, 0x62, 0x85, 0x90, 0xd2, 0xf2, 0x0f, 0x52, 0x71, 0xc8, 0x86, 0xdd,
	0xc4, 0xbd, 0x38, 0x56, 0xc7, 0x9e, 0x30, 0x33, 0x6e, 0x08, 0x4f, 0xc1, 0x5b, 0xf0, 0x2a, 0x5d,
	0x66, 0xc9, 0x0a, 0x41, 0xf2, 0x22, 0x28, 0x63, 0x0f, 0xc4, 0x90, 0x44, 0x2c, 0xba, 0xcb, 0x9c,
	0xfb, 0xcd, 0x99, 0x73, 0xae, 0x62, 0x68, 0x47, 0x43, 0xa6, 0x83, 0x14, 0x95, 0x62, 0x31, 0x06,
	0x29, 0x93, 0xa7, 0xf9, 0x48, 0x05, 0x23, 0x29, 0xb4, 0x20, 0x6e, 0xaa, 0xe2, 0xf6, 0xdd, 0x38,
	0xd1, 0xc3, 0x7c, 0x10, 0x44, 0x22, 0x3d, 0x88, 0x45, 0x2c, 0x0e, 0xcc, 0x6c, 0x90, 0x7f, 0x30,
	0x27, 0x73, 0x30, 0xbf, 0x8a, 0x3b, 0xf4, 0xab, 0x03, 0xd7, 0x42, 0x1c, 0xf1, 0xc9, 0x2b, 0x9c,
	0x0c, 0x04, 0x93, 0x27, 0x6f, 0x8c, 0x25, 0xa1, 0xd0, 0xec, 0x25, 0x59, 0xcc, 0xb1, 0xaf, 0xd0,
	0x73, 0x3a, 0xce, 0xfe, 0x76, 0xb7, 0x71, 0xfe, 0xfd, 0x66, 0x2d, 0xfc, 0x23, 0x1b, 0x06, 0x39,
	0x46, 0x3a, 0x39, 0x43, 0xaf, 0x5e, 0x61, 0xac, 0x4c, 0xf6, 0x60, 0x2b, 0x44, 0x95, 0x7c, 0x46,
	0xcf, 0x5d, 0x02, 0x4a, 0x8d, 0xdc, 0x81, 0x46, 0x28, 0xc6, 0xca, 0x6b, 0x74, 0xdc, 0xfd, 0x9d,
	0x7b, 0xad, 0x20, 0x55, 0x71, 0x60, 0x83, 0x74, 0x73, 0xad, 0x45, 0x16, 0x8a, 0x71, 0x68, 0x18,
	0xfa, 0x18, 0x76, 0x4d, 0xd0, 0x17, 0x19, 0x4f, 0x32, 0x2c, 0x63, 0x5a, 0x03, 0xe7, 0x3f, 0x0c,
	0x1e, 0x96, 0x06, 0x76, 0xfe, 0x3c, 0x39, 0xf9, 0xab, 0x83, 0xd3, 0xa9, 0xaf, 0xe8, 0x40, 0x19,
	0x5c, 0xaf, 0x5c, 0x7c, 0x2a, 0x64, 0x84, 0x46, 0xb9, 0xa8, 0x35, 0xd1, 0x97, 0xb0, 0xfb, 0x4f,
	0x6c, 0xf2, 0x00, 0x2e, 0x17, 0x07, 0xdb, 0xef, 0xc6, 0x8a, 0x7e, 0x4f, 0xb2, 0x33, 0xe4, 0x62,
	0x84, 0xa1, 0x65, 0xe9, 0x7b, 0x68, 0xad, 0x46, 0xc8, 0x6d, 0xd8, 0x39, 0x14, 0x99, 0xd2, 0x32,
	0x8f, 0xb4, 0x90, 0xa6, 0xae, 0x5b, 0x66, 0x59, 0x1e, 0x10, 0x0f, 0x1a, 0x47, 0x4c, 0x33, 0x13,
	0xf6, 0x4a, 0x09, 0x18, 0x85, 0x52, 0xd8, 0x2a, 0x3c, 0x17, 0xcc, 0x3b, 0xfc, 0xa4, 0x8d, 0x49,
	0xd3, 0x32, 0x0b, 0x85, 0x3e, 0x82, 0x66, 0xc1, 0xf4, 0x25, 0x5f, 0x8f, 0x91, 0x16, 0xb8, 0x7d,
	0xc9, 0xbd, 0xfa, 0xd2, 0x60, 0x21, 0xd0, 0x23, 0xb8, 0x5a, 0x5c, 0x3f, 0x64, 0x9c, 0x0f, 0x58,
	0x74, 0xba, 0xc1, 0x63, 0x7d, 0xd0, 0x00, 0x48, 0xb9, 0x48, 0xfc, 0x98, 0xa3, 0xd2, 0xc7, 0x43,
	0x91, 0xe1, 0x86, 0xd0, 0xf7, 0xc1, 0xab, 0xf0, 0xcf, 0x50, 0xbc, 0x16, 0x11, 0xd3, 0xc9, 0xc6,
	0xaa, 0xdc, 0xbe, 0xd2, 0x1b, 0x27, 0x3a, 0x1a, 0x16, 0x7f, 0xcd, 0x0d, 0x79, 0xdb, 0x70, 0xe9,
	0x6d, 0x8e, 0x72, 0x52, 0x69, 0x5d, 0x48, 0xa4, 0x03, 0xdb, 0x3d, 0x96, 0xe2, 0x31, 0xa2, 0xac,
	0x7c, 0x2b, 0xbf, 0x55, 0x7a, 0xcb, 0x2e, 0xb6, 0x9b, 0x4f, 0xd6, 0x3f, 0xd2, 0xdd, 0x9b, 0xfe,
	0xf4, 0x6b, 0xe7, 0x33, 0xdf, 0x99, 0xce, 0x7c, 0xe7, 0xc7, 0xcc, 0x77, 0xbe, 0xcc, 0xfd, 0xda,
	0x74, 0xee, 0xd7, 0xbe, 0xcd, 0xfd, 0xda, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x79, 0x32, 0x11,
	0x77, 0x41, 0x04, 0x00, 0x00,
}

func (m *ReplyKeyboardMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyKeyboardMarkup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyKeyboardMarkup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessageMarkups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	i--
	if m.Resize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i--
	if m.Selective {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i--
	if m.SingleUse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ReplyInlineMarkup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyInlineMarkup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyInlineMarkup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessageMarkups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplyKeyboardHide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyKeyboardHide) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyKeyboardHide) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Selective {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *ReplyKeyboardForceReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyKeyboardForceReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplyKeyboardForceReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.Selective {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	i--
	if m.SingleUse {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *KeyboardButtonRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyboardButtonRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyboardButtonRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Buttons) > 0 {
		for iNdEx := len(m.Buttons) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buttons[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChatMessageMarkups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KeyboardButtonEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyboardButtonEnvelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyboardButtonEnvelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(m.Constructor))
	i--
	dAtA[i] = 0x8
	return len(dAtA) - i, nil
}

func (m *Button) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Button) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Button) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ButtonUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ButtonUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ButtonCallback) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonCallback) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ButtonCallback) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ButtonRequestPhone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonRequestPhone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ButtonRequestPhone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ButtonRequestGeoLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonRequestGeoLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ButtonRequestGeoLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ButtonSwitchInline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonSwitchInline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ButtonSwitchInline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i--
	if m.SamePeer {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	i -= len(m.Query)
	copy(dAtA[i:], m.Query)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Query)))
	i--
	dAtA[i] = 0x12
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ButtonBuy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ButtonBuy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ButtonBuy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	i -= len(m.Text)
	copy(dAtA[i:], m.Text)
	i = encodeVarintChatMessageMarkups(dAtA, i, uint64(len(m.Text)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintChatMessageMarkups(dAtA []byte, offset int, v uint64) int {
	offset -= sovChatMessageMarkups(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ReplyKeyboardMarkup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 2
	n += 2
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovChatMessageMarkups(uint64(l))
		}
	}
	return n
}

func (m *ReplyInlineMarkup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovChatMessageMarkups(uint64(l))
		}
	}
	return n
}

func (m *ReplyKeyboardHide) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *ReplyKeyboardForceReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	n += 2
	return n
}

func (m *KeyboardButtonRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Buttons) > 0 {
		for _, e := range m.Buttons {
			l = e.Size()
			n += 1 + l + sovChatMessageMarkups(uint64(l))
		}
	}
	return n
}

func (m *KeyboardButtonEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChatMessageMarkups(uint64(m.Constructor))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovChatMessageMarkups(uint64(l))
	}
	return n
}

func (m *Button) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	return n
}

func (m *ButtonUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	l = len(m.Url)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	return n
}

func (m *ButtonCallback) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovChatMessageMarkups(uint64(l))
	}
	return n
}

func (m *ButtonRequestPhone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	return n
}

func (m *ButtonRequestGeoLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	return n
}

func (m *ButtonSwitchInline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	l = len(m.Query)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	n += 2
	return n
}

func (m *ButtonBuy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Text)
	n += 1 + l + sovChatMessageMarkups(uint64(l))
	return n
}

func sovChatMessageMarkups(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChatMessageMarkups(x uint64) (n int) {
	return sovChatMessageMarkups(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReplyKeyboardMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyKeyboardMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyKeyboardMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SingleUse = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Resize = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &KeyboardButtonRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyInlineMarkup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyInlineMarkup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyInlineMarkup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &KeyboardButtonRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyKeyboardHide) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyKeyboardHide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyKeyboardHide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Selective")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyKeyboardForceReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyKeyboardForceReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyKeyboardForceReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SingleUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SingleUse = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selective", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selective = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyboardButtonRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyboardButtonRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyboardButtonRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buttons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buttons = append(m.Buttons, &KeyboardButtonEnvelope{})
			if err := m.Buttons[len(m.Buttons)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyboardButtonEnvelope) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyboardButtonEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyboardButtonEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Constructor")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Button) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Button: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Button: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonUrl) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Url")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonCallback) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonCallback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonCallback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonRequestPhone) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonRequestPhone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonRequestPhone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonRequestGeoLocation) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonRequestGeoLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonRequestGeoLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonSwitchInline) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonSwitchInline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonSwitchInline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SamePeer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SamePeer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Query")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ButtonBuy) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ButtonBuy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ButtonBuy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipChatMessageMarkups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChatMessageMarkups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("Text")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChatMessageMarkups(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChatMessageMarkups
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChatMessageMarkups
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChatMessageMarkups
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChatMessageMarkups
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChatMessageMarkups
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChatMessageMarkups        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChatMessageMarkups          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChatMessageMarkups = fmt.Errorf("proto: unexpected end of group")
)
